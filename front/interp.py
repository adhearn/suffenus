"""
Simple interpreter for the Three Address Code generated by the compiler frontend.
"""

import copy

CALL_TOKEN = "CALL"
CASE_TOKEN = "CASE"
CONDITIONAL_TOKEN = "IF"
JUMP_TOKEN = "JUMP"
LINDEXED_TOKEN = "LINDEXED"
NO_OP_TOKEN = "<NO OP>"
PARAM_TOKEN = "PARAM"
RETURN_TOKEN = "RETURN"
RINDEXED_TOKEN = "RINDEXED"

TAC_BINOP = "BINOP"
TAC_CALL = "CALL"
TAC_CASE = "CASE"
TAC_COPY = "COPY"
TAC_CONDITIONAL = "IF"
TAC_JUMP = "JUMP"
TAC_LINDEXED_COPY = "LINDEXED"
TAC_NO_OP = "NOOP"
TAC_PARAM = "PARAM"
TAC_RETURN = "RETURN"
TAC_RINDEXED_COPY = "RINDEXED"
TAC_UNOP = "UNOP"


class Quad:
    def __init__(self, parts):
        self.raw = parts

    @staticmethod
    def parse_quad_string(quad_string):
        parts = quad_string.split()
        if quad_string == NO_OP_TOKEN:
            return NoOp(parts)
        if parts[0] == CASE_TOKEN:
            return Case(parts)
        elif parts[0] == CONDITIONAL_TOKEN:
            return Conditional(parts)
        elif parts[0] == JUMP_TOKEN:
            return Jump(parts)
        elif parts[0] == LINDEXED_TOKEN:
            return LeftIndexedCopy(parts)
        elif parts[0] == PARAM_TOKEN:
            return Param(parts)
        elif parts[0] == RETURN_TOKEN:
            return Return(parts)
        elif parts[0] == RINDEXED_TOKEN:
            return RightIndexedCopy(parts)
        else:
            if CALL_TOKEN in parts:
                return Call(parts)
            elif len(parts) == 3 or PARAM_TOKEN in parts:
                return Copy(parts)
            elif len(parts) == 5:
                return Binop(parts)

        print("Unable to parse quad: {}".format(parts))

    @staticmethod
    def parse_address(addr):
        if addr.isdecimal():
            return int(addr)
        else:
            return addr

    @staticmethod
    def parse_label(label):
        return label


class Binop(Quad):
    def __init__(self, parts):
        super().__init__(parts)
        self.type = TAC_BINOP
        self.lhs = self.parse_address(parts[0])
        self.op = parts[3]
        self.arg1 = self.parse_address(parts[2])
        self.arg2 = self.parse_address(parts[4])


class Call(Quad):
    def __init__(self, parts):
        super().__init__(parts)
        self.type = TAC_CALL
        self.lhs = self.parse_address(parts[0])
        self.label = self.parse_label(parts[3])
        self.params = int(parts[4])


class Case(Quad):
    def __init__(self, parts):
        super().__init__(parts)
        self.type = TAC_CASE
        self.arg1 = self.parse_address(parts[1])
        self.arg2 = self.parse_address(parts[2])
        self.label = self.parse_label(parts[3])


class Conditional(Quad):
    def __init__(self, parts):
        super().__init__(parts)
        self.type = TAC_CONDITIONAL
        self.arg1 = self.parse_address(parts[1])
        self.arg2 = self.parse_address(parts[3])
        self.relop = parts[2]
        self.label = self.parse_label(parts[5])


class Copy(Quad):
    def __init__(self, parts):
        super().__init__(parts)
        self.type = TAC_COPY
        self.lhs = self.parse_address(parts[0])
        if PARAM_TOKEN in parts:
            self.param = True
            self.param_index = self.parse_address(parts[3])
        else:
            self.param = False
            self.rhs = self.parse_address(parts[2])


class Jump(Quad):
    def __init__(self, parts):
        super().__init__(parts)
        self.type = TAC_JUMP
        self.target = self.parse_label(parts[1])

class LeftIndexedCopy(Quad):
    def __init__(self, parts):
        super().__init__(parts)
        self.type = TAC_LINDEXED_COPY
        self.lhs = self.parse_address(parts[1])
        self.index = self.parse_address(parts[2])
        self.rhs = self.parse_address(parts[3])

class NoOp(Quad):
    def __init__(self, parts):
        super().__init__(parts)
        self.type = TAC_NO_OP


class Param(Quad):
    def __init__(self, parts):
        super().__init__(parts)
        self.type = TAC_PARAM
        self.address = self.parse_address(parts[1])


class Return(Quad):
    def __init__(self, parts):
        super().__init__(parts)
        self.type = TAC_RETURN
        self.address = self.parse_address(parts[1])


class RightIndexedCopy(Quad):
    def __init__(self, parts):
        super().__init__(parts)
        self.type = TAC_RINDEXED_COPY
        self.lhs = parts[1]
        self.rhs = self.parse_address(parts[2])
        self.index = self.parse_address(parts[3])

    def __str__(self):
        return "<RIndexCopy {} = {}[{}]>".format(self.lhs, self.rhs, self.index)


class Environment:
    def __init__(self, parent=None):
        if parent:
            self.env = parent
        else:
            self.env = {}

    def primitive_result(self, obj):
        return type(obj) == int or type(obj) == list

    def lookup(self, key, recursive=True):
        if not recursive:
            return self.env.get(key)
        else:
            res = self.env.get(key)
            if self.primitive_result(res):
                return res
            elif res is not None:
                return self.lookup(res, recursive=recursive)
            else:
                return key

    def extend(self, key, value):
        new_env = copy.copy(self.env)
        new_env[key] = value
        return Environment(new_env)

    def copy(self):
        return Environment(copy.deepcopy(self.env))


class Interpreter:
    def __init__(self, quad_strings):
        self.quads = []
        self.env = Environment()
        self.label_indexes = {}
        self.next_index = 0
        self.params = []
        self.return_indexes = []
        self.return_value = None
        self.cur_fn_params = []
        self.initialize(quad_strings)

    def initialize(self, quad_strings):
        processed_statements = []
        for i, stmt in enumerate(quad_strings):
            parts = stmt.split(":")
            if len(parts) > 1:
                for label in parts[:-1]:
                    self.label_indexes[label] = i
                    self.env = self.env.extend(label, i)
                stmt = parts[-1].strip()
            processed_statements.append(Quad.parse_quad_string(stmt))
        self.quads = processed_statements
        self.next_index = self.label_indexes['main']

    def label_index(self, label):
        primitive_label = self.env.lookup(label)
        return primitive_label

    def _eval(self):
        while 0 <= self.next_index < len(self.quads):
            quad = self.quads[self.next_index]
            if quad.type == TAC_BINOP:
                res = self.apply_binop(quad.op, quad.arg1, quad.arg2)
                self.env = self.env.extend(quad.lhs, res)
                self.next_index += 1
            elif quad.type == TAC_CALL:
                self.cur_fn_params = self.params[(-quad.params):]
                self.params = self.params[:(-quad.params)]
                return_index = self.next_index + 1
                self.next_index = self.label_index(quad.label)
                return_value_var = quad.lhs

                # We have to save the old environment - this is our hacky way of emulating the call stack
                old_env = self.env
                self.env = self.env.copy()
                self.return_indexes.append((return_value_var, return_index, old_env))
            elif quad.type == TAC_CASE:
                # A case is just a simple "macro" for if
                if self.apply_relop('==', quad.arg1, quad.arg2):
                    self.next_index = self.label_index(quad.label)
                else:
                    self.next_index += 1
            elif quad.type == TAC_CONDITIONAL:
                if self.apply_relop(quad.relop, quad.arg1, quad.arg2):
                    self.next_index = self.label_index(quad.label)
                else:
                    self.next_index += 1
            elif quad.type == TAC_COPY:
                if quad.param:
                    param_value = self.cur_fn_params[quad.param_index]
                    self.env = self.env.extend(quad.lhs, param_value)
                else:
                    self.env = self.env.extend(quad.lhs, quad.rhs)
                self.next_index += 1
            elif quad.type == TAC_JUMP:
                self.next_index = self.label_index(quad.target)
            elif quad.type == TAC_LINDEXED_COPY:
                ls = self.env.lookup(quad.lhs)
                index = self.env.lookup(quad.index)
                rhs = self.env.lookup(quad.rhs)
                if ls and type(ls) == list:
                    if len(ls) <= index:
                        bigger_ls = [None for _ in range(index + 1)]
                        for i in range(len(ls)):
                            bigger_ls[i] = ls[i]
                        ls = bigger_ls
                else:
                    ls = [None for _ in range(index + 1)]
                ls[index] = rhs
                self.env = self.env.extend(quad.lhs, ls)
                self.next_index += 1
            elif quad.type == TAC_NO_OP:
                self.next_index += 1
            elif quad.type == TAC_PARAM:
                self.params.append(self.env.lookup(quad.address))
                self.next_index += 1
            elif quad.type == TAC_RETURN:
                res = self.env.lookup(quad.address)
                self.return_value = res
                if self.return_indexes:
                    return_value_var, self.next_index, self.env = self.return_indexes.pop()
                    self.env = self.env.extend(return_value_var, res)
                else:
                    return res
            elif quad.type == TAC_RINDEXED_COPY:
                ls = self.env.lookup(quad.rhs)
                index = self.env.lookup(quad.index)
                self.env = self.env.extend(quad.lhs, ls[index])
                self.next_index += 1
            else:
                print("Quad type not handled: ", quad.type)
                return
        return self.env.lookup(self.return_value)


    @staticmethod
    def parse_quad_strings(quad_strings):
        return [Quad(s) for s in quad_strings]

    @staticmethod
    def eval(filelike):
        quad_strings = [l for l in filelike.splitlines()]

        interp = Interpreter(quad_strings)
        return interp._eval()

    def apply_relop(self, op, arg1, arg2):
        arg1 = self.env.lookup(arg1)
        arg2 = self.env.lookup(arg2)

        if op == ">":
            return arg1 > arg2
        elif op == "<":
            return arg1 < arg2
        elif op == ">=":
            return arg1 >= arg2
        elif op == "<=":
            return arg1 <= arg2
        elif op == "==":
            return arg1 == arg2
        else:
            raise Exception("Unknown relop: {}".format(op))

    def apply_binop(self, op, arg1, arg2):
        arg1 = self.env.lookup(arg1)
        arg2 = self.env.lookup(arg2)

        if op == "+":
            return arg1 + arg2
        elif op == "-":
            return arg1 - arg2
        elif op == "*":
            return arg1 * arg2
        else:
            raise Exception("Unknown binop: {}".format(op))

test_str = """<NO OP>
main: <NO OP>
x = 2
y = 4
TMP2 = x
TMP3 = y
TMP4 = TMP2 + TMP3
RETURN TMP4
"""

if __name__ == "__main__":
    res = Interpreter.eval(test_str)
    print("RES: {}".format(res))
