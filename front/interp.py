"""
Simple interpreter for the Three Address Code generated by the compiler frontend.

Also, please don't judge me for this code. I was challenging myself to write this in 30 minutes, and it shows.
"""

NO_OP_TOKEN = "<NO OP>"
JUMP_TOKEN = "JUMP"
RETURN_TOKEN = "RETURN"

def parse_address(addr):
    if addr.isdecimal():
        return int(addr)
    else:
        return addr

def env_lookup(env, key):
    if type(key) == int:
        return key
    else:
        return env_lookup(env, env[key])

def apply_binop(op, arg1, arg2):
    if op == "+":
        return arg1 + arg2
    elif op == "-":
        return arg1 - arg2
    elif op == "*":
        return arg1 * arg2

def tac_eval(f):
    label_indexes = {}
    stmts = [l for l in f.splitlines()]

    processed_statements = []
    pending_labels = []

    for i, stmt in enumerate(stmts):
        parts = stmt.split(":")
        if len(parts) > 1:
            for label in parts[:-1]:
                label_indexes[label] = i
            stmt = parts[-1].strip()
        processed_statements.append(stmt)

    env = {}

    next_index = 0
    return_indexes = [-1]
    return_value = None
    while next_index < len(processed_statements):
        if next_index == -1:
            return return_value
        stmt = processed_statements[next_index]

        if stmt == NO_OP_TOKEN:
            next_index += 1
            continue

        stmt_parts = stmt.split()
        stmt_op = stmt_parts[0]
        if stmt_op == JUMP_TOKEN:
            label = stmt_parts[1]
            next_index = label_indexes[label]
            continue
        elif stmt_op == RETURN_TOKEN:
            next_index = return_indexes.pop()
            return_value = env_lookup(env, stmt_parts[1])
            continue
        else:  # BINOP or COPY
            if len(stmt_parts) == 3:  # COPY
                lhs = stmt_parts[0]
                rhs = parse_address(stmt_parts[2])
                env[lhs] = rhs
            elif len(stmt_parts) == 5:
                lhs = stmt_parts[0]
                arg1 = parse_address(stmt_parts[2])
                arg2 = parse_address(stmt_parts[4])

                arg1 = env_lookup(env, arg1)
                arg2 = env_lookup(env, arg2)

                op = stmt_parts[3]
                result = apply_binop(op, arg1, arg2)
                env[lhs] = result
        next_index += 1


test_str = """<NO OP>
main: <NO OP>
x = 2
y = 4
TMP2 = x
TMP3 = y
TMP4 = TMP2 + TMP3
RETURN TMP4
"""

if __name__ == "__main__":
    res = tac_eval(test_str)
    print("RES: {}".format(res))
